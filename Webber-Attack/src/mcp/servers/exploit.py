"""
MCP Server 2: Exploitation (ENHANCED)
Handles active exploitation via shell commands and raw HTTP attacks.

NEW: ensure_tool - Auto-install missing tools on demand

Tools:
- shell:       Run any exploitation command (sqlmap --dump, hydra, msfconsole, etc.)
- http_attack: Fire a single raw HTTP request. Session-persistent, NO payload encoding.
               This is the key differentiator – SQLi/XSS payloads arrive at the server
               exactly as the agent typed them.
- http_batch:  Fire N http_attack requests in parallel. Ideal for IDOR enumeration,
               XSS payload shotgunning, brute-force style HTTP attacks.
- ensure_tool: Check if a tool is installed; if not, install it automatically.

Design rules:
  - Zero target knowledge. Zero hardcoded attack logic.
  - The AI agent constructs everything. This server just fires.
"""

import asyncio
import time
import shutil
from pathlib import Path
from typing import Dict, Any, List, Optional
from concurrent.futures import ThreadPoolExecutor

import requests
import urllib3
from rich.console import Console

# Suppress SSL warnings – pentest context, self-signed certs are normal
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

console = Console()


class ExploitServer:
    """
    Exploitation MCP Server (ENHANCED with ensure_tool).
    Exposes raw capabilities – zero target knowledge, zero attack logic.
    The AI agent decides what to do. This server just executes.
    """

    def __init__(self):
        self.name = "exploit"
        self.tools: Dict[str, Dict] = {}
        self._initialized = False
        # All -o / > output files land here instead of polluting project root
        self.cache_dir = Path(__file__).resolve().parents[3] / "cache"
        # Session store: session_id -> requests.Session
        # Sessions persist across the entire agent lifetime so cookies / tokens
        # survive across iterations (login → grab token → IDOR chain works).
        self._sessions: Dict[str, requests.Session] = {}
        # Thread pool for blocking HTTP I/O – keeps asyncio event loop free
        self._executor = ThreadPoolExecutor(max_workers=16)
        
        # ═════════════════════════════════════════════════════════════════
        # NEW: Tool installation cache
        # ═════════════════════════════════════════════════════════════════
        self._tool_check_cache: Dict[str, bool] = {}  # tool_name -> is_installed
        self._installation_log: List[str] = []  # Track what we've installed

    # =========================================================================
    # Lifecycle
    # =========================================================================

    async def initialize(self):
        """Check which exploitation tools are installed."""
        if self._initialized:
            return

        # Ensure cache directory exists
        self.cache_dir.mkdir(exist_ok=True)

        tool_defs = {
            "sqlmap":     "sqlmap",
            "hydra":      "hydra",
            "curl":       "curl",
            "python3":    "python3",
            "nuclei":     "nuclei",
            "msfconsole": "msfconsole",
            "wfuzz":      "wfuzz",
            "john":       "john",
            "hashcat":    "hashcat",
            "nmap":       "nmap",
            "nikto":      "nikto",
            "ffuf":       "ffuf",
            "gobuster":   "gobuster",
        }

        for name, binary in tool_defs.items():
            path = shutil.which(binary)
            is_installed = path is not None
            self.tools[name] = {
                "description": f"Exploitation tool: {name}",
                "binary": binary,
                "installed": is_installed,
                "path": path,
            }
            # Cache the check result
            self._tool_check_cache[name] = is_installed

        self._initialized = True
        installed = [t for t, i in self.tools.items() if i["installed"]]
        console.print(f"    [dim]Exploit tools available: {', '.join(installed)}[/dim]")

    def get_tools(self) -> List[str]:
        return list(self.tools.keys()) + ["shell", "http_attack", "http_batch", "ensure_tool"]

    def get_tool_info(self) -> Dict[str, Dict]:
        info = dict(self.tools)
        info["shell"]       = {"description": "Execute any shell/exploitation command", "installed": True}
        info["http_attack"] = {"description": "Raw HTTP request with session persistence (no payload encoding)", "installed": True}
        info["http_batch"]  = {"description": "Parallel raw HTTP requests", "installed": True}
        info["ensure_tool"] = {"description": "Check if tool is installed; install if missing", "installed": True}
        return info

    async def shutdown(self):
        self._clear_all_sessions()
        self._executor.shutdown(wait=False)
        self._initialized = False

    # =========================================================================
    # Dispatch
    # =========================================================================

    async def execute_tool(self, tool_name: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Route to the correct handler based on tool_name."""

        if tool_name == "shell":
            cmd = params.get("command")
            if not cmd:
                raise ValueError("'command' is required for shell")
            return await self._execute_raw(cmd, params.get("timeout", 300))

        elif tool_name == "http_attack":
            return await self._execute_http(params)

        elif tool_name == "http_batch":
            reqs = params.get("requests", [])
            if not reqs:
                raise ValueError("'requests' list is required for http_batch")
            return await self._execute_http_batch(reqs)
        
        # ═════════════════════════════════════════════════════════════════
        # NEW: ensure_tool handler
        # ═════════════════════════════════════════════════════════════════
        elif tool_name == "ensure_tool":
            tool = params.get("tool")
            if not tool:
                raise ValueError("'tool' parameter is required for ensure_tool")
            return await self._ensure_tool(tool, params.get("package"))

        else:
            # Graceful fallback: if the agent just passes a command, treat as shell
            cmd = params.get("command")
            if cmd:
                return await self._execute_raw(cmd, params.get("timeout", 300))
            raise ValueError(f"Unknown exploit tool: {tool_name}")

    # =========================================================================
    # Shell – same subprocess pattern as ReconServer
    # =========================================================================

    async def _execute_raw(self, command: str, timeout: int = 300) -> Dict[str, Any]:
        """Execute a raw shell command via asyncio subprocess."""
        try:
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=self.cache_dir,
            )
            stdout, stderr = await asyncio.wait_for(
                process.communicate(), timeout=timeout
            )
            return {
                "output":      stdout.decode("utf-8", errors="replace"),
                "errors":      stderr.decode("utf-8", errors="replace"),
                "return_code": process.returncode,
                "command":     command,
            }
        except asyncio.TimeoutError:
            process.kill()
            return {
                "output": "", "errors": f"Timed out after {timeout}s",
                "return_code": -1, "command": command,
            }
        except Exception as e:
            return {
                "output": "", "errors": str(e),
                "return_code": -1, "command": command,
            }

    # =========================================================================
    # HTTP Attack – single request
    # =========================================================================

    def _get_or_create_session(self, session_id: Optional[str]) -> requests.Session:
        """
        Return an existing session or create + store a new one.
        Reusing a session_id across calls preserves cookies, auth headers, etc.
        """
        if session_id and session_id in self._sessions:
            return self._sessions[session_id]

        session = requests.Session()
        if session_id:
            self._sessions[session_id] = session
        return session

    def _fire_request(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Blocking HTTP request – runs in the thread pool.

        Params the agent controls:
            method          : GET | POST | PUT | DELETE | PATCH | OPTIONS | HEAD
            url             : full URL (http://...)
            headers         : {header_name: value}
            cookies         : {cookie_name: value}   – merged on top of session cookies
            data            : raw body STRING        – requests does NOT re-encode strings,
                              so SQLi/XSS payloads land exactly as written
            json_data       : body as JSON dict      – sets Content-Type: application/json
            files           : {field_name: content}  – multipart upload
            session_id      : string key to reuse a session across calls
            timeout         : per-request timeout (seconds, default 30)
            follow_redirects: True/False (default True)
        """
        method           = params.get("method", "GET").upper()
        url              = params.get("url", "")
        headers          = params.get("headers", {})
        cookies          = params.get("cookies", {})
        data             = params.get("data", None)
        json_data        = params.get("json_data", None)
        files            = params.get("files", None)
        session_id       = params.get("session_id") or params.get("session")
        timeout          = params.get("timeout", 30)
        follow_redirects = params.get("follow_redirects", True)

        if not url:
            return {"success": False, "error": "URL is required"}

        start = time.time()

        try:
            session = self._get_or_create_session(session_id)

            kwargs: Dict[str, Any] = {
                "method":          method,
                "url":             url,
                "headers":         headers,
                "cookies":         cookies,
                "timeout":         timeout,
                "allow_redirects": follow_redirects,
                "verify":          False,   # pentest – don't bail on self-signed certs
            }

            # --- Body: mutually exclusive priority: json > files > data ---
            if json_data is not None:
                kwargs["json"] = json_data
            elif files is not None:
                # Multipart – handy for file-upload vulns
                kwargs["files"] = {k: (k, v) for k, v in files.items()} if isinstance(files, dict) else files
                if data is not None:
                    kwargs["data"] = data        # form fields alongside the file
            elif data is not None:
                # Raw string – requests sends it byte-for-byte.
                # This is the critical path for SQLi / XSS payloads.
                kwargs["data"] = data

            response = session.request(**kwargs)
            elapsed  = round(time.time() - start, 3)

            return {
                "success":       True,
                "status_code":   response.status_code,
                "headers":       dict(response.headers),
                "body":          response.text[:50000],   # cap to avoid flooding context
                "body_length":   len(response.text),
                "response_time": elapsed,
                "final_url":     response.url,            # URL after any redirects
                "session_id":    session_id,
                "session_cookies": dict(session.cookies.get_dict()),
            }

        except requests.exceptions.Timeout:
            return {"success": False, "error": f"Timeout after {timeout}s", "url": url}
        except requests.exceptions.ConnectionError as e:
            return {"success": False, "error": f"Connection error: {str(e)[:200]}", "url": url}
        except Exception as e:
            return {"success": False, "error": str(e)[:200], "url": url}

    async def _execute_http(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Non-blocking wrapper: runs _fire_request in the thread pool."""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(self._executor, self._fire_request, params)

    # =========================================================================
    # HTTP Batch – parallel requests
    # =========================================================================

    async def _execute_http_batch(self, requests_list: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Fire every request in requests_list concurrently.
        Each item is a full http_attack params dict.
        Results come back in the same order as input.
        """
        if not requests_list:
            return {"success": False, "error": "Empty requests list"}

        loop = asyncio.get_event_loop()
        tasks = [
            loop.run_in_executor(self._executor, self._fire_request, req)
            for req in requests_list
        ]
        raw_results = await asyncio.gather(*tasks, return_exceptions=True)

        # Normalise any exceptions into error dicts
        results = []
        for r in raw_results:
            if isinstance(r, Exception):
                results.append({"success": False, "error": str(r)[:200]})
            else:
                results.append(r)

        ok = sum(1 for r in results if r.get("success"))

        return {
            "success":    True,
            "total":      len(requests_list),
            "successful": ok,
            "failed":     len(requests_list) - ok,
            "results":    results,
        }

    # =========================================================================
    # NEW: Tool Installation (ensure_tool)
    # =========================================================================

    async def _ensure_tool(self, tool: str, package: Optional[str] = None) -> Dict[str, Any]:
        """
        Check if a tool is installed. If not, install it automatically.
        
        Params:
            tool: The binary name to check (e.g., "nuclei", "ffuf")
            package: Optional package name if different from binary (e.g., tool="john", package="john-the-ripper")
        
        Returns:
        {
            "success": bool,
            "installed": bool,
            "action": "already_installed" | "installed_now" | "install_failed",
            "message": str,
            "path": str (if installed)
        }
        """
        # Check cache first
        if tool in self._tool_check_cache and self._tool_check_cache[tool]:
            tool_path = shutil.which(tool)
            return {
                "success": True,
                "installed": True,
                "action": "already_installed",
                "message": f"{tool} is already installed",
                "path": tool_path
            }
        
        # Check if actually installed (cache might be stale)
        tool_path = shutil.which(tool)
        if tool_path:
            self._tool_check_cache[tool] = True
            return {
                "success": True,
                "installed": True,
                "action": "already_installed",
                "message": f"{tool} is already installed",
                "path": tool_path
            }
        
        # Not installed - try to install
        package_name = package or tool
        
        # Try different package managers
        install_commands = [
            f"apt-get install -y {package_name}",  # Debian/Ubuntu/Kali
            f"apt install -y {package_name}",      # Alternative apt syntax
            f"yum install -y {package_name}",      # RHEL/CentOS
            f"dnf install -y {package_name}",      # Fedora
        ]
        
        for cmd in install_commands:
            try:
                # Check if the package manager exists
                pkg_mgr = cmd.split()[0]
                if not shutil.which(pkg_mgr):
                    continue
                
                console.print(f"    [yellow]Installing {tool} via {pkg_mgr}...[/yellow]")
                
                # Run installation
                result = await self._execute_raw(cmd, timeout=180)  # 3 min timeout for install
                
                if result["return_code"] == 0:
                    # Verify installation
                    tool_path = shutil.which(tool)
                    if tool_path:
                        self._tool_check_cache[tool] = True
                        self._installation_log.append(f"{tool} installed via {pkg_mgr}")
                        console.print(f"    [green]✓ {tool} installed successfully[/green]")
                        return {
                            "success": True,
                            "installed": True,
                            "action": "installed_now",
                            "message": f"{tool} installed successfully via {pkg_mgr}",
                            "path": tool_path,
                            "install_output": result["output"][:500]
                        }
            
            except Exception as e:
                continue
        
        # Installation failed
        console.print(f"    [red]✗ Failed to install {tool}[/red]")
        return {
            "success": False,
            "installed": False,
            "action": "install_failed",
            "message": f"Failed to install {tool}. Try installing manually or use different tool.",
            "path": None
        }

    # =========================================================================
    # Session helpers
    # =========================================================================

    def clear_session(self, session_id: str):
        """Drop a single session (cookies, connection pool, everything)."""
        if session_id in self._sessions:
            self._sessions[session_id].close()
            del self._sessions[session_id]

    def _clear_all_sessions(self):
        for s in self._sessions.values():
            s.close()
        self._sessions.clear()